# 第7章 用函数实现模块化程序设计

## 7.1 为什么要用函数
1. 背景：
   1. 简单的C程序功能单一，而在处理实际问题中，要求程序的功能比较多，是的程序规模比较大。如果把所有程序代码都写在一个main函数中，就降低了程序的易阅读性和易维护性。
   2. 此外，有时程序中要多次实现某一功能，就需要多次重复编写实现该功能的程序代码，这使程序冗长，不精炼。
   
	因此，人们采用模块化程序设计的思路，将一批常用的程序代码事先编写好，需要用时就可以直接调用，这种实现各种不同功能的程序代码就称为函数。
2. 说明：
   - 一个C程序由一个或多个程序模块组成，每一个程序模块作为一个源程序文件。一个源程序文件可以为多个C程序共用。
   - 一个源程序文件由一个或多个函数以及其他有关内容（如指令、数据声明与定义等）组成。在程序编译时以源程序文件为单位进行编译。
   - C程序的执行从main函数开始，在main函数中结束。
   - 不能调用main函数，main函数是被操作系统调用的。
3. 函数的分类：
   - 从用户使用角度，函数可分为库函数和自定义函数。
   - 从函数形式上，函数分为无参函数和有参函数

## 7.2 怎样定义函数
C语言规定，在程序中用到的所有函数，必须“先定义，后使用”。即将函数名、函数返回值类型、函数实现的功能及参数个数与类型这些信息通知编译系统.

### 7.2.1 定义函数
1. 定义无参函数

		类型名 函数名()
		{
			函数体
		}
	或

		类型名 函数名(void)
		{
			函数体
		}
	函数体包括声明部分和语句部分。
2. 定义有参函数

		类型名 函数名(形式参数表列)
		{
			函数体
		}
	函数体包括声明部分和语句部分。
3. 定义空函数

		类型名 函数名()
		{}
	因为在程序设计中，根据需要确定若干个模块，分别由一些函数实现，其中一些次要功能将安排在以后扩充，所以在将来准备扩充功能的地方写一个空函数，这样做使程序的结构清楚，可读性好。
## 7.3 调用函数
### 7.3.1 函数调用的形式
1. 一般形式：**函数名(实参表列)**
   - 调用无参函数，则“实参表列”可以没有，但括号不能省略。
   - 调用有参函数，如果“实参表列”有多个实参，则各参数间用逗号隔开。
2. 3种函数调用方式（按函数调用在程序中出现的形式和位置来分）
   1. 函数调用语句
   2. 函数表达式
   3. 函数参数
### 7.3.2 函数调用的数据传递
在调用函数过程中，系统把实参的值传递给被调用函数的形参，该值只在函数调用期间有效，这里发生的实参与形参之间的数据传递，常称为“虚实结合”，即形参是实参的一份临时拷贝。

说明：
   1. 实参可以是常量、变量或表达式。但要求它们有确定的值。
   2. 实参于形参的类型应相同或赋值兼容。
### 7.3.3 函数调用过程
1. 发生函数调用时，函数的形参被临时分配内存单元。
2. 将实参对应的值传递给形参。
3. 执行被调函数
4. 通过return语句将函数值带回到主调函数，如果不需要返回值，则不需要return语句。
5. 调用结束形参单元被释放。

	注意：实参向形参的数据传递是“值传递”，单向传递。如果执行一个被调用函数时，形参的值发生变化，但实参单元是保留并维持原值，没有改变的，因为实参和形参在内存中占不同的内存单元，实参无法得到形参的值。
### 7.3.4 函数的返回值
1. 函数的返回值是通过函数中的return语句获得的；
2. 函数值的类型是定义函数时指定的类型；
3. 在定义函数时指定的函数类型一般应该和return语句中的表达式类型一致，如果函数值的类型和return语句中表达式的值不一致，则以函数类型为准。
4. 对于不带回值的函数，应当定义函数为“void类型”

## 7.4 函数声明和函数原型
在一个函数中调用另一个函数需要具备的条件：
1. 被调函数必须是库函数或用户自定义函数；
2. 使用库函数应该在文件开头用#include指令将所需头文件包含在本文件中；
3. 自定义函数如果在调用它的函数后，应该在主调函数中对被调用做声明。
   - 声明的作用是把函数名、函数参数个数和参数类型等信息通知编译系统。

函数声明：已定义的函数的首行，再加一个分号，就成了函数的声明。

用函数首部作为函数声明的目的：
- 便于对函数调用的合法性进行检查
  1. 要求函数名、函数类型、参数个数和参数顺序必须与函数声明一致；
  2. 实参类型必须与函数声明中的形参类型相同或复制兼容。

函数声明中的形参名省写，而只写形参的类型。
- 编译系统只关心和检查参数个数和参数类型，而不检查参数名。

函数原型：函数的首行称为函数原型。

一般形式：
1. 函数类型 函数名(参数类型1 参数名1,参数类型2 参数名2,...参数类型n 参数名n);
2. 函数类型 函数名(参数类型1,参数类型2,...参数类型n);

函数的定义和声明的区别：
1. 函数的定义是指对函数功能的确立；
2. 函数的声明是把函数的名字、函数类型以及形参的类型、个数和顺序通知编译系统，在调用该函数时进行对照检查，它不包含函数体。
## 7.5 函数的嵌套调用
函数不能嵌套定义，但可以嵌套调用。

**fgets函数**：
- 一个C语言中的输入函数，用于从标准输入流（通常是键盘）读取一行字符串。
- 原型：`char *fgets(char *str, int n, FILE *stream)`;
其中， `str` 是一个字符数组，用于存储读取的字符串； `n` 是最大读取字符数； `stream` 是要读取的文件流，通常使用 `stdin` 表示标准输入流。
- 执行过程：fgets函数会读取输入流中的一行字符，包括换行符，然后将其存储到 `str` 指向的字符数组中，直到达到最大字符数 `n` 或者遇到换行符为止。
- 返回值：读取成功后，fgets函数会返回指向存储字符串的字符数组的指针，如果发生错误或到达文件末尾，则返回NULL。
- **注意**：fgets函数会将换行符 `\n` 也读取并存储在字符串中，因此如果需要去除换行符，可以使用字符串处理函数来处理。

## 7.6 函数的递归调用
在调用一个函数的过程中又出现直接或间接的调用该函数本身，称为函数的递归调用。
- 只应出现有限次数的、有终止的递归调用，可以用if语句来控制。

## 7.7 数组做函数参数
1. 数组元素做函数实参
   - 是“值传递”方式
   - 数据传递方向是从实参到形参的单向传递。
2. 数组名作函数实参
   - 向形参（数组或指针变量）传递的是数组第一个元素的地址。
     - 形参为一维数组时，可以留一个空的[]而不指定其大小，因为C语言编译系统并不检查形参数组的大小，只是将数组的首元素地址传给形参数组名。
     - 形参为二维数组时，可以不指定第一维的大小，只保留第二维的大小。因为二维数组在内存中是按行存放的，因此必须指定第二维的大小。
   - **注意**：数组名作函数实参时，和形参共占同一段内存单元，形参的变化会时实参同时变化。

## 7.8 局部变量和全局变量
定义变量可能有3种情况：
1. 函数的开头定义；
2. 在函数内的复合语句中定义；
3. 在函数外部定义。

每一个变量都有一个作用域，即它们在什么范围内有效。

从作用域（即从空间）的角度来观察，变量可以分为局部变量和全局变量。

### 7.8.1 局部变量
在一个函数内部或复合语句内部定义的变量。

**说明**：
1. 主函数中定义的变量也只在主函数中有效。
2. 不同函数可以使用同名的变量。
3. 形参也是局部变量。
4. 可以在复合语句内部定义变量。

### 7.8.2 全局变量
在函数之外定义的变量称为外部变量，外部变量是全局变量（全程变量）

**说明**：
1. 全局变量可以为本文件中其他函数所共用。
2. 全局变量的有效范围是从定义位置开始到本源文件结束。
3. 全局变量增加了函数间数据类型的渠道
   - 利用全局变量可通过函数调用来得到一个以上的值。
4. 为了便于和区别局部变量区分，习惯将全局变量的第一个字母大写。

**建议在非必要时不使用全局变量**：
- 原因如下：
  1. 全局变量在程序的全部执行过程中都占用存储单元；
  2. 全局变量使函数通用性降低了，在程序设计中，要求模块的“内聚性”强、与其他模块的“耦合性”弱。而全局变量的执行情况受外部变量的影响，如果外部变量移动文件时与其他文件的变量同名，就会出现问题，这减低了程序的可靠性和通用性。
  3. 全局变量过多会使程序不清晰，难以判断每个瞬时各个外部变量的值。

## 7.9 变量的存储方式和生存期

### 7.9.1 变量的存储方式
从变量值存在的数据（即生存期）来观察，有的变量在程序运行的整个过程都是存在的，而有的则是在调用其所在的函数时才临时分配存储单元，在函数调用结束后该存储单元就马上释放了。也就是说变量的存储方式有两种不同的方式：静态存储方式和动态存储方式。
1. 静态存储方式是指在程序运行期间由系统分配固定的存储空间的方式。
2. 动态存储方式则是程序运行期间根据需要进行动态的分配存储空间的方式。

内存中供用户使用的存储空间可分为3部分：
1. 程序区
2. 静态存储区
3. 动态存储区

数据分别存放在静态存储区和动态存储区中。
1. 静态存储区中存放以下数据：
   - 外部变量
   - 用关键字static声明的局部变量（函数内有效）
   - 用关键字static声明的外部变量（本文件内有效）

	在程序开始执行时编译系统就给它们分配存储区，程序执行完毕就释放。在程序执行过程中它们占据固定的存储单元。
2. 动态存储区中存放以下数据：
   - 函数形式参数。在调用函数时非形参分配存储空间；
   - 函数中调用的没有用关键字static声明的变量，即自动变量；
   - 函数调用时的现场保护和返回地址等。

	对以上数据，在函数调用开始时分配动态存储空间，函数结束时释放这些空间。在程序执行过程中，这种分配和释放是动态的，每次调用时分配的存储空间的地址可能不相同。

C语言中，变量和函数都有两个属性：数据类型和数据的存储类别。存储类别是指数据在内存中存储的方式。  
C的存储类别包括4部分：自动的（auto）、静态的（static）、寄存器的（register）、外部的（extern）。

### 7.9.2 局部变量的存储类别
1. 自动变量（auto变量）
   - 指函数中的形参、函数内定义的局部变量（包括复合语句中定义的局部变量）；
   - 动态地分配存储空间，数据存储在动态存储区；
   - 在调用函数时，系统分配存储空间，调用结束就自动释放；
   - 关键字“auto”可以省略。
2. 静态局部变量（static局部变量）
   - 指用关键字static声明的函数中的局部变量；
   - 该变量在函数调用结束后不消失而继续保留原值，即其占用的存储单元不释放。
   
   **说明**

   1. 静态局部变量属于静态存储类别，在**静态存储区**内分配存储单元，在程序整个运行期间不释放；
   2. 静态局部变量是在编译时赋初值的，即只赋值一次，在程序运行时它已有初值。每次调用函数时时保留的上次调用结束时的值。
   3. 定义静态局部变量不赋初值时，编译时自动赋初值0或空字符'\0'，而自动变量在定义时不赋初值，它的值是一个不确定的值。
   4. 静态局部变量在函数调用后仍然存在，但其他函数不能引用，因为它是局部变量。
   5. 静态局部变量多占内存，若非必要，不要多用。
3. 寄存器变量（register变量）
   1. 由于寄存器的存取速度远高于内存，把使用频繁的变量存放在CPU的寄存器中，可以提高执行效率。
   2. 这种变量叫寄存器变量，用关键字register作声明。
   3. 现在的计算机会自动地将频繁使用的变量存放在寄存器，实际上用register声明的必要性不大。 

### 7.9.3 全局变量的作用域
1. 生存期：全局变量存放在静态存储区中的，因此它们的生存期是固定的，存在于程序的整个运行过程。
2. 作用域：一般来说，全局变量的作用域从定义出开始，到本程序文件的末尾。
3. 扩展外部变量的作用域：
   1. 在一个文件内扩展外部变量的作用域
      - 用关键字extern对在定义点之前的外部变量作声明，表示把该外部变量的作用域扩展到此位置（不是全文件）。
      - 提倡将外部变量的定义**放在引用它的所有函数之前**，避免在函数中多加一个extern声明
      - 用extern声明外部变量时，类型名可写可省写。
   2. 将外部变量的作用域扩展到其他文件
      - 编译时遇到extern，先在本文件中找外部变量的定义，如果找不到，就在连接时从其他文件中找外部变量的定义。
   3. 将外部变量的作用域限制在本文件
      - 只需在每个文件中定义外部变量时加上static声明。
      - 这种外部变量称为静态外部变量。
      - 在程序设计中，为程序的模块化、通用性提供了方便。
      - **说明**
        1. 外部变量加static声明的作用是变量作用域的扩展问题。
        2. 声明存储类型的作用不同：
           1. 对于局部变量来说，声明存储类型的作用是指定 变量的存储区域以及由此产生的生存期问题；
           2. 对于全局变量来说，由于都是在编译时分配内存的，都存放在静态存储区，声明存储类型的作用是变量作用域的扩展问题。
4. 用static声明一个变量的作用是：
   - 对局部变量用static声明，把它分配到静态存储区，该变量在整个程序执行期间不释放，其所分配的空间始终存在。
   - 对全局变量用static声明，则该变量的作用域只限于本文件模块。

### 7.9.4 存储类别小结
对一个数据的定义，需要指定两种属性：数据类型和存储类别，分别使用两个关键字。
1.从作用域角度分，有局部变量和全局变量。采用的存储类别：

$$ 
按作用域角度分=
\begin{cases}
局部变量\\
全局变量 
\end{cases}
$$ 

$$
局部变量=
\begin{cases}
自动变量，即动态局部变量&（离开函数，值就消失）\\
静态局部变量&（离开函数，值仍保留）\\
寄存器变量&（离开函数，值就消失）\\
（形式参数可以定义为自动变量和寄存器变量）
\end{cases}
$$

$$
全局变量=
\begin{cases}
静态外部变量&（只限本文件引用）\\
外部变量&（即非静态的，允许其他文件引用）
\end{cases}
$$

2. 从变量存在的时间（生存期）来区分，有动态存储和静态存储两种类型。静态存储时程序整个运行时间都存在，而动态存储则是在调用函数时临时分配单元。

$$ 
按变量的生存期分=
\begin{cases}
动态存储\\
静态存储 
\end{cases}
$$ 

$$
动态存储=
\begin{cases}
自动变量&（本函数内有效）\\
寄存器变量&（本函数内有效）\\
形式参数&（本函数内有效）
\end{cases}
$$

$$
静态存储=
\begin{cases}
静态局部变量&（函数内有效）\\
静态外部变量&（本文件内有效）\\
外部变量&（用extern声明后，可被其他文件引用）
\end{cases}
$$

3. 从变量存放的位置来区分：

$$
按变量值存放的位置分=
\begin{cases}
内存中静态存储区\\
内存中动态存储区：自动变量和形式参数\\
CPU中的寄存器：寄存器变量
\end{cases}
$$

$$
内存中静态存储区=
\begin{cases}
静态局部变量\\
静态外部变量&（函数外部静态变量）\\
外部变量&（可为其他文件引用）
\end{cases}
$$

4. 作用域和生存期：
   1. 如果一个变量在某个文件或函数范围内是有效的，就称该范围为该变量的作用域；变量在此作用域内“可见”，称为变量的“可见性”。
   2. 如果一个变量值在某一时刻是存在的，就认为这一时刻是该变量的生存期，或成该变量此刻“存在”。
5. **static对局部变量和全局变量的作用**
   1. 对局部变量来说，它使变量由动态存储方式改变为静态存储方式；
   2. 对全局变量来说，它使变量局部化（局部于本文件），但仍为静态存储方式；
   3. 从作用域角度看，凡是static声明的变量，其作用域或是局限于函数内（静态局部变量），或是局限于本文件内（静态外部变量）。

## 7.10 变量的声明和定义
广义来说，声明包括定义，但并非所有声明都是定义。
1. 定义性声明：在声明部分出现的变量需要建立存储空间，简称定义。
2. 引用性声明：在声明部分出现的变量不需要建立存储空间。

一般的，把建立存储空间的声明称为定义，而把不需要建立存储空间的声明称为声明。

## 7.11 内部函数和外部函数
根据函数能否被其他源文件调用，将函数区分为内部函数和外部函数。
### 7.11.1 内部函数
- 函数只能被本文件中其他函数所调用，又称静态函数；
- 一般形式：**static 类型名 函数名(形参表)**。
- 通常把只能由本文件使用的函数和外部变量放在文件的开头，前面都以static使之局部化，其他文件不能引用。
### 7.11.2 外部函数
- 函数可供其他文件调用。
- 一般形式：
extern 类型名 函数名(形参表);
- 如果定义函数是省略extern，则默认为外部函数。
- 函数原型的作用：把函数的作用与扩展到定义该函数的文件之外（不必使用extern）

## 附加内容：

"Segmentation fault"（分段错误）通常是在C或C++程序中遇到的一种错误类型。它表示程序试图访问无法访问的内存地址，导致操作系统终止程序的执行。

Segmentation fault错误通常是由以下几种情况引起的：

1. 空指针访问：当程序试图通过空指针访问内存时，会导致分段错误。

2. 数组越界：当程序试图访问数组超出其边界范围的元素时，也会导致分段错误。

3. 栈溢出：如果程序中使用的栈空间超出了其允许的范围，也可能导致分段错误。

4. 未初始化的变量：如果程序中使用了未初始化的变量，其值可能是未定义的，可能会导致分段错误。

要解决分段错误，您可以进行以下几个步骤：

1. 检查代码中是否存在空指针访问或数组越界的情况。确保在访问指针或数组之前进行有效性检查。

2. 确保所有的变量都被正确初始化，避免使用未初始化的变量。

3. 检查函数调用和参数传递是否正确，确保没有传递无效的指针或数组。

4. 使用调试工具（如GDB）来跟踪程序的执行，定位出错的位置。

通过以上步骤，您可以定位和修复导致分段错误的问题。
