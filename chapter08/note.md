# 第8章 善于利用指针

指针是C语言中的一个重要概念，也是C语言的一个重要特色。正确而灵活得运用它，可以使程序简洁、紧凑、高效。

## 8.1 指针是什么

### 8.1.1 数据在内存中是如何的存储的，又是如何读取的。

1. 内存
内存是由一系列的存储单元组成的。每个存储单元都有一个唯一的地址，用于访问和存储数据。内存的主要构成部分是：
   - 位（bit）：内存的最小单位，可以存储一个二进制位（0或1）。
   - 字节（byte）：由8个位组成，通常用来存储一个字符。
   - 字（word）：由若干个字节组成，字的大小可以根据计算机系统的不同而变化，一般为2个或4个字节。
   - 内存单元（memory cell）：由一个或多个字组成，用于存储数据。
   - 内存地址（memory address）：用于唯一标识内存中的每个存储单元。
   - 内存容量（memory capacity）：指内存可以存储的数据量，通常以字节为单位。

   总的来说，内存是由存储单元、地址和容量组成的，用于存储和读取计算机程序和数据。
2. 数据的存储
如果程序定义了一个变量，在对程序进行编译时，系统就会给这个变量分配内存单元。编译系统根据程序中定义的变量类型，分配一定长度的字节。
3. 地址和指针
   - 地址：对于内存区中的每一个字节都取一个编号，这就是**地址**。
   - 指针：由于通过地址能够找到所需的内存单元，可以说，**地址指向该变量单元**，指向就是通过地址来体现的。因此，**将地址形象化地称为“指针”**。意思是通过它能找到以它为地址的内存单元。一个变量的地址称为该变量的“指针”，
   - 指针变量：如果有一个变量专门用来存放另一个变量的地址，则称它为指针变量，指针变量就是地址变量，用来存放地址，指针变量的值是指针（地址）。
4. 数据的访问方式
   1. 直接访问：假设程序已定义了一个变量i，一般是通过变量名i来引用变量的值。实际上是通过变量名i找到存储单元的地址，从而对存储单元继续存取操作。这种直接按变量名继续的访问，称为“直接访问”方式。
   2. 间接访问：即将变量名i的地址存放在另一个变量中，然后通过该变量来找到变量i的地址，从而访问变量i。

## 8.2 指针变量

存放地址的变量是指针变量，它用来指向另一个对象（如变量、数组、函数、指针等）

### 8.2.2 定义指针变量

1. 一般形式：**类型名 * 指针变量名;**  
   左端的类型名是在定义指针变量时必须指定的“基类型”，用来指定此指针变量可以指向的变量的类型。  
   **说明**：指针变量是基本数据类型派生出来的类型，它不能离开基本类型而存在。  
   定义指针变量时**注意**：
      - 指针变量名前的“*”表示该变量的类型为指针型变量；
      - 在定义指针变量时必须指定的“基类型”，基类型确保按正确的存储单元的长度以及数据的存储形式存取数据。
2. 指针变量中只能存放指针。

### 8.2.3 引用指针变量

1. 给指针变量赋值
2. 引用指针变量指向的变量
3. 引用指针变量的值

```c
   int a, *p;
   p=&a;                //把a的地址赋给指针变量p
   printf("%d",*p);     //以整数形式输出指针变量p所指向的变量的值，即a的值
   *p=1;                //将整数1赋给p当前所指向的变量，由于p指向变量a，相当于把1赋给a，即a=1
   printf("%o",p);      //以八进制形式输出指针变量p的值，由于p指向a，相当于输出a的地址，即&a
```

### 8.2.4 指针变量作函数参数

C语言中实参和形参之间的数据传递是单向的“值传递”方式，不可能通过执行调用函数来改变实参指针变量的值。但是可以改变实参指针变量所值指变量的值。

**注意**：函数的调用只可以得到一个返回值，而使用指针变量可以得到多个变化的值。

## 8.3 通过指针引用数组

### 8.3.1 数组元素的指针

C语言中，数组名（不包括形参数组名，形参数组并不占实际的内存单元）代表数组中首元素的地址。

### 8.3.2 在指针指向数组元素时：

加减一个整数，系统根据其基类型，加减整数个数组元素所占用的字节数。
两个指针能相减，不能相加（无实际意义）。
实际上，在编译时对数组元素a[i]就是按*(a+i)处理的，[]实际上是变址运算符。

### 8.3.3 通过指针指向数组元素

速度快，不必每次都计算地址。  
**注意**：数组名代表数组首元素的地址，它是一个指针型常量，在程序运行期间是固定不变的，无法自增。
1. 实际上指针变量可以指向数组以后的存储单元，引用数组后的元素，编译系统并不认为非法。
2. 在编译时，对下标的处理方法是转换为地址的，如果p指向a[3]，则p[2]是a[3+2]。  
**技巧**：
\*p++; $\equiv$ \*(p++);由于*和++同优先级，结合方向为自右向左

### 8.3.4 用数组名作函数参数

实际上，C编译都是将形参数组名作指针变量处理的。  
**注意**：`sizeof`(形参数组名)的值是4或8。  
从应用角度看，形参数组与实参数组共占同一段内存单元，在调用函数期间，如果改变了形参数组的值，实参数组的值也随之改变。  
**注意**：实参数组名是一个固定的地址，是指针常量，形参数组名时指针变量。

### 8.3.5 通过指针引用多维数组

指针可以指向一维数组中的元素，也可以指向多维数组中的元素。

1. 多维数组元素的地址
   
   从二维数组的角度看，二维数组名代表二维数组首元素的地址，而二维数组首元素是一个由多个整型元素组成的整型数组，因此二维数组名代表的是首行的首地址。

   在二维数组`a[i][j]`中:
   |表现形式|含义|值|
   |:----:|:----:|:----:|
   |`a`|首行的首地址|`&a[0][0]`|
   |`a+i`|序号i行的首地址|`a[i]`的首地址|
   |`a[i]`|i行0列元素地址|`&a[i][0]`|
   |`*(a+i)`|i行0列元素地址|`&a[i][0]`|
   |`a[i]+j`|i行j列元素地址|`&a[i][j]`|
   |`*(a+i)+j`|i行j列元素地址|`&a[i][j]`|
   |`*(*(a+i)+j)`|i行j列元素的值|`a[i][j]`|

   **强调**：
   二维数组名是指向行的，如`a`；一维数组名是指向列元素的，如`a[i]`；  
   在指向行的指针前面加一个`*`，就转换成指向列的指针；
   在指向列的指针前面加一个`&`，就转换成指向行的指针。  
   **注意**：
   二维数组`a[i][j]`中并不存在`a[i]`这样一个实际的数据存储单元。
   `&a[i]`和`a[i]`值相等，但指向的对象不同，即指针的基类型不同。

2. 指向二维数组元素的指针变量
   1. 指向数组元素的指针变量
      - 计算`a[i][j]`在数组中的相对位置的公式：`i*m+j`，其中`m`为二维数组的列数。
      若指针变量p指向`a[0][0]`，`a[i][j]`的地址为`p+(i*m+j)`。
   2. 指向由m个元素组成的一维数组的指针变量
      - 一般形式：`类型名 (*指针变量名)[元素个数]`  
      注意`()`不可缺少，因为`[]`运算级别高。
      - 指针变量的类型：类型名` * [元素个数]`
      - 指针变量的基类型：一维数组
      - `*(指针变量+i)+j`:
         - i是以指针变量的基类型为单位；
         - j是以元素为单位；
      - `*(指针变量+i)` $\equiv$ `二维数组名[i]` $\equiv$ `&二维数组名[i][0]`
      - `*(指针变量+i)+j` $\equiv$ `&二维数组名[i][j]`

## 8.4 通过指针引用字符串        

### 8.4.1 字符串的引用方式

C语言的对字符串常量是按字符数组处理的，在内存中开辟一个字符数组用来存放该字符串常量，但这个字符数组没有名字，不能通过数组名来引用，只能通过指针变量来引用。
%s格式符输出字符串时，系统会输出指针变量所指向的字符串第一个字符，然后自动使指针变量加1，使之指向下一个字符，再输出该字符......如此直到遇到字符串结束标志'\0'为止。
**注意**：在内存中字符串的最后被自动加了一个'\0'

### 8.4.3字符指针变量和字符数组比较

1. 字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是地址；（字符串第一个字符的地址）
2. 可以对字符指针变量赋值，但不能对数组名赋值；（数组名是地址，为常量）
3. 数组可以在定义是对各元素赋初值，但不能用赋值语句对字符数组中全部元素整体赋值；
   1. **错误**：`char str[14];str[]="I love China!";`
4. 编译时为字符数组分配若干存储单元，以存放各元素的值，而对字符指针变量，只分配一个存储单元（4/8个字节）。
   1. 如果定义了字符数组，但未对它赋初值，这时数组中的元素的值是不可预料的，
   2. 如果定义了字符指针变量，应当及时把一个字符变量或字符数组元素的地址赋给它。
   3. **错误**：`char *a;scanf("%s",a)`;a的值不可预料。
5. 指针变量的值可以改变，而数组名代表一个固定的值（数组首元素的地址），不能改变。
6. 字符数组中各元素的值可以改变（可以对它们再赋值），但字符指针变量指向的字符串常量中的内容不可以被再赋值。
7. 若字符指针变量指向字符串常量，就可以用指针变量带下标的形式引用所指的字符串中的字符。
   1. 如：char *a="I love China!";a[5];
8. 用指针变量指向一个格式字符串，可以用它代替格式字符串。

## 8.5 指向函数的指针

### 8.5.1 函数指针

如果程序中定义了一个函数，在编译时，编译系统为函数代码分配的一段存储空间，这段存储空间的起始地址（又称入口地址）称为函数的指针。

1. 一般形式：类型名 (\*指针变量名)(函数参数表列); ()优先级高于\*

### 8.5.3 说明：

1. 在一个程序中，一个指针变量可以先后指向同类型的不同函数。
2. 对指向函数的指针变量不能进行算术运算。

### 8.5.4 用指向函数的指针做函数参数

如果每次调用的函数不固定，只要在每次调用函数时，给出不同的函数名作实参。

## 8.6 返回指针值的函数
一般形式：类型名 * 函数名(参数表列);

## 8.7 指针数组和多重指针

### 8.7.1 指针数组

一个数组，若其元素均为指针类型数据，称为指针数组。
1. 一般形式：`类型名 * 数组名[数组长度]`
2. 用途：比较适合用来指向若干个字符串，使字符串处理更加灵活。
   1. 一般方法，字符串本身就是字符数组，因此要设计一个二维的字符数组才能存放多个字符串，但在定义二维数组时，需要定义列数，而实际上各字符串长度不等，会浪费许多内存单元。
   2. 所以有指针数组中的元素指向各字符串，这样各字符串的长度可以不同，而且移动指针变量的值比移动字符串所花的时间少得多。
### 8.7.2 指向指针数据的指针

1. 一般形式：类型名 **指针变量名
2. 说明：
   1. *运算符的结合性从右到左
   2. 指针数组的元素也可以不指向字符串，而指向整型数据或实型数据等。
### 8.7.3 指针数组作main函数的参数

实际上，在某些情况下，main函数可以有参数，
`int main(int argc,char * argv[])`
1. 其中，argc和argv是程序的“命令行参数”，
   argc（argument count的缩写，意思是参数个数），
   argv（argument vector的缩写，意思是参数向量），

## 8.8 动态内存分配与指向它的指针变量

### 8.8.1 内存的动态分配
非静态的局部变量（包括形参）是分配在内存中的动态存储区，这个存储区称为“栈区”。
除此之外，C语言还允许建立内存动态分配区域，以存放一些临时用的数据，这些数据不必在程序的声明部分定义，也不必等到函数结束才释放，而是需要时随时开辟，不需要是随时释放。这些数据是临时存放在一个特别的自由存储区，称为“堆区”。由于未在声明部分定义它们为变量或数组，因此只能通过指针来引用。对内存的动态分配主要是通过系统提供的库函数来实现的，
主要有`malloc、calloc、free、realloc`这4个函数。
1. 使用`malloc`函数
   1. 函数原型：`void *malloc(unsigned int size);`
   2. 作用：在内存的动态存储区中分配一个长度为size的连续空间；
   3. 返回值：所分配区域的第一个字节的地址；如果此函数未成功地执行（例如空间不足），则返回空指针（NULL）。
   4. 基类型：void，即不指向任何类型的数据，只提供一个地址。


2. 使用`calloc`函数
   1. 函数原型：`void *calloc(unsigned n,unsigned size);`
   2. 作用：在内存的动态存储区中分配n个长度为size的类型空间，这个空间一般比较大足以保存一个数组。
   3. 动态数组：用calloc函数为一维数组开辟动态空间，n为数组元素个数，每个元素长度为size。
   4. 返回值：指向所分配域的起始位置的指针，如果分配不成功，返回NULL.
3. 使用free函数
   1. 函数原型：`void free(void *p);`
   2. 作用：释放指针变量p所指向的动态空间，使这部分空间能重新被其他变量使用。p应是最近一次调用`calloc`或`malloc`函数时得到的函数返回值。
   3. 返回值：无
4. 使用`realloc`函数
   1. 函数原型：`void *realloc(void *p,unsigned int size);`
   2. 作用：如果已经通过calloc或malloc函数获得了动态空间，可以用realloc函数重新分配。
   3. 返回值：最近一次调用calloc或malloc函数时得到的函数返回值，如果分配不成功，返回NULL。

   以上4个函数的声明在stdlib.h头文件中。
   **说明**：以前的C版本提供的calloc和malloc函数得到的是指向字符型数据的指针，
   其原型为`char *malloc(unsigned int size);`
   如果把开辟的区域用来存放整数，则要进行类型转换，如int *pt=(int *)malloc(100);
   要说明的是类型转换只是产生一个临时的中间值赋给了pt，并没有改变malloc函数本身的类型。

### 8.8.3 void指针类型

C99允许使用基类型为void的指针类型。可以定义一个基类型为void的指针变量（即void *型变量），它不指向任何类型的数据。应理解为“指针空类型”或“不指向确定的类型”的数据
**说明**：当把void指针赋值给不同基类型的指针变量（或相反）时，编译系统会自动进行转换。

## 8.9 有关指针变量的小结

4. 指针变量的类型及含义

|变量定义|类型表示|含义|
|:----:|:----:|:----:|
|`int i;`|`int`|定义整型变量i|
|`int *p;`|`int *`|定义p为指向整型数据的指针变量|
|`int a[5];`|`int [5]`|定义整型数组a，它有5个元素|
|`int *p[4];`|`int *[4]`|定义指针数组p，它由4个指向整型数据的指针元素组成|
|`int (*p)[4];`|`int (*)[4]`|定义数组指针变量p，指向包含4个元素的一维数组|
|`int f();`|`int ()`|f为返回整型函数值的函数|
|`int *p();`|`int *()`|p为返回一个指针的函数，该指针指向整型数据|
|`int(*p)();`|`int(*)()`|p为指向函数的指针，该函数返回一个整型值|
|`int **p;`|`int **`|p是一个指针变量，指向一个指向整型数据的指针变量|
|`void *p;`|`void *`|p是一个指针变量，基类型为void，不指向具体的对象|

5. 指针运算
   1. 指针变量加减一个整数：将该指针变量的原值和他指向的变量所占用的存储单元的字节数向加减。
   2. 指针变量赋值：
   **注意**：不应把一个整数赋给指针变量。
   3. 指针变量相减：在指向同一数组元素时，相减的差是指针之间的元素个数。
   4. 指针变量比较：在指向同一数组元素时，指向前面的指针变量“小于”指向后面元素的指针变量。
   5. 指针变量可以是空值，即该指针变量不指向任何变量。即`p=NULL`;其中`NULL`是一个符号常量，代表整数0；在`stdio.h`头文件中对`NULL`进行了定义：`#define NULL 0`,它是p指向地址为0的单元。系统保证该单元不作它用（不存放有效数据）。
6. 使用指针的优点：
   1. 提高程序效率；
   2. 在定义函数时，当指针指向的变量的值改变时，指向值能够为主调函数使用，即可以从函数调用得到多个可改变的值。
   3. 可以实现动态分配。