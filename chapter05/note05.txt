                                第五章 循环结构程序设计
5.1 为什么需要循环控制
  用一个循环语句，实现需要重复执行的程序段。
5.2 用while语句实现循环
  while 语句的一般形式：
     while（表达式）语句
	 只要循环表达式为真，就执行循环体语句。
5.3 用do...while语句实现循环
  先无条件执行循环体，然后判断循环条件是否成立。
  一般形式：
    do
		语句
	while（表达式）；
5.4 用for()语句实现循环
	一般形式：
	  for（表达式1；表达式2；表达式3）
	    语句
	  表达式1：设置初始条件，只执行一次。表达式可省略，分号不能。
	  表达式2：循环条件表达式，判定是否继续循环。可略
	  表达式3：作为循环的调整。可略
	  可以理解为：for(循环变量赋初值;循环条件;循环变量增值) 语句
	  （1）for语句可改写成while语句，二者无条件等价；
	  （2）表达式1可以省略，但分号不能；
	  （3）表达式2也可以省略，此时循环无终止；
	  （4）表达式3也可以省略，但应另外设法保证循环正常结束；
	  （5）可以只有表达式2；
	  （6）3个表达式都可以省略；
	  （7）表达式1可以是与循环变量无关的表达式，表达式3也可以是与循环控制无关的其他表达式；
	  （8）表达式1,和3也可以是逗号表达式；
        逗号表达式
          即包含一个以上的简单表达式，中间用逗号间隔。
          在逗号表达式内按自左至右顺序求解，整个表达式的值为最右边的表达式的值。
	  （9）表达式2也可以是数值表达式或字符表达式，只要其值非0,就执行循环体!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	  （10）C99允许在for语句的表达式1中定义变量并赋初值。!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  C语言的for语句比其他语言（如FORTRAN，Pascal）中的for语句功能强得多。
  可以把循环体和一些与循环控制无关的操作也作为表达式1或表达式3出现，注意程序可以短小简洁。
  但应注意：过分利用这一特点会使for语句显得杂乱，可读性降低，
  最好不用把与循环控制无关的内容放到for语句中。

5.5 循环的嵌套
	一个循环体内又包含了另一个完整的循环结构，称为循环的嵌套。
5.7 改变循环执行的状态
  5.7.1 用break语句提前终止循环
    break语句的作用是使流程调到循环体之外，接着执行循环体之后的语句。
    break语句可以使流程跳出switch结构，继续执行switch语句下面的语句，
    还可以用来从循环体内跳出循环体，即提前结束循环，接着执行循环下面的语句。
    break语句只能用在循环语句和switch语句中，不能单独使用。
  5.7.2 用continue语句提前结束本次循环
    continue 语句的作用是结束本次循环，即跳过循环体下面尚未执行的语句，
    转到循环体结束点之前，接着执行for语句中的表达式3，然后进行下一次是否执行循环的判定。
  5.7.3 break语句和continue语句的区别
    continue语句只结束本次循环，而不是终止整个循环的执行。
    而break语句则是结束整个循环过程，不再判断执行循环的条件是否成立。

问题：windows，Clion在debug的时候，printf不会实时输出，在程序结束后才会输出。
分析：从终端键盘向计算机输入时，是在按Enter键以后才将一批数据一起送到内存缓冲区中去的。
解决：①在程序开始时候禁用缓冲区：setbuf(stdout, 0);
     ②输出语句后调用函数fflush(stdout);
头文件：#include<stdio.h>
定义函数：int fflush(FILE * stream);
函数说明：fflush()会强迫将缓冲区内的数据写回参数stream指定的文件中，
如果参数stream为NULL，fflush()会将所有打开的文件数据更新。
返回值：成功返回0，失败返回EOF，错误代码存于errno中。

fflush()也可用于标准输入（stdin）和标准输出（stdout），用来清空标准输入输出缓冲区。
    stdin是standard input的缩写，即标准输入，一般是指键盘；
标准输入缓冲区是用来暂存从键盘输入的内容的缓冲区。
    stdout是standard output 的缩写，即标准输出，一般是指显示器；
标准输出缓冲区是用来暂存将要显示的内容的缓冲区。
    清空标准输出缓冲区，
    刷新输出缓冲区，即将缓冲区的东西输出到屏幕上
    如果圆括号里是已写打开的文件的指针，则将输出缓冲区的内容写入该指针指向的文件，否则清除输出缓冲区。
这里的stdout是系统定义的标准输出文件指针，默认情况下指屏幕，就是把缓冲区的内容写到屏幕上。
但是从代码中看不出缓冲区会有什么内容，所以它实际上没有起什么作用。

约数
    如果数a能被数b整除，a就叫做b的倍数，b就叫做a的约数。约数和倍数都表示一个整数与另一个整数的关系，不能单独存在。
质因数
    就是一个数的约数，并且是质数。
互质
    若N个整数的最大公因数是1，则称这N个整数互质。
公约数
    定义：如果 d|a（d 整除 a）且 d|b，那么 d 是 a 与 b 的 公约数。
    性质：如果 d|a 且 d|b，那么 d|(ax + by); x,y ∈ Z(任意整数)
最大公约数
    定义：两个非零整数 a 和 b 的公约数里最大的就是 最大公约数。
相关等式跟推论：
    等式 1：如果 a|b 且 b|a 那么 a = ±b
    等式 2：如果 d|a 且 d|b 那么 d|(ax + by); x,y ∈ Z
    等式 3：a mod n = a - n⌊a/n⌋(向下整除); a∈Z,n∈N*(正整数)
    推论 1：对任意整数 a , b，如果 d|a 且 d|b 则 d|gcd(a, b)
    求法：
    ① 质因数分解法：
       把每个数分别分解质因数，再把各数中的全部公有质因数提取出来连乘，所得的积就是这几个数的最大公约数。
    ② 短除法：
       先用这几个数的公约数连续去除，一直除到所有的商互质为止，
       然后把所有的除数连乘起来，所得的积就是这几个数的最大公约数。
    ③ 辗转相除法（欧几里德算法）：
       定理：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。
       以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数。
       一、基础知识
       欧几里得算法的原理是 GCD递归定理
       GCD递归定理：
       对任意 非负整数 a 和 任意 整数 b，gcd(a,b) = gcd(b, a mod b)
       为了证明这个定理，我们首先需要知道一下有关 gcd 的基本知识跟相关等式跟推论。
       二、证明过程
       要获得结论gcd(a,b) = gcd(b, a mod b)
       利用等式 1证明gcd(a,b)|gcd(b, a mod b) 且 gcd(b,a mod b)|gcd(a,b)。

       证明 gcd(a,b)|gcd(b,a mod b)
       设 d = gcd(a, b)
       ∴ d|a 且 d|b
       ∵ 由 等式 3 可知：(a mod b) = a - qb q = ⌊a/b⌋
       ∴ a mod b 是 a 与 b 的线性组合
       ∴ 由 等式 2 可知 ：d|(a mod b)
       ∵ d|b 且 d|(a mod b)
       ∴ 由 推论 1 可知 d|gcd(b, a mod b)
       等价结论： gcd(a, b)|gcd(b, a mod b)

       证明 gcd(b,a mod b)|gcd(a,b)
       设 c = gcd(b, a mod b)
       ∴ c|b 且 c|(a mod b)
       ∵ a = qb + r
          r = a mod b
          q = ⌊a/b⌋
       ∴ a 是 b 和 (a mod b) 的线性组合
       ∴ 由 等式 2 可知：c|a
       ∵ c|a 且 c|b
       ∴ 由 推论 1 可知：c|gcd(a, b)
       等价结论： gcd(b, a mod b)|gcd(a, b)s

       证明 gcd(a,b) = gcd(b, a mod b)
       由 上述两个结论 可知：
       gcd(a, b)|gcd(b, a mod b)
       gcd(b, a mod b)|gcd(a, b)
       ∴ 由 等式 1 可知：
        gcd(a, b) = gcd(b, a mod b)
        证明结束
    ④ 更相减损法（等值算法）：
       第一步：任意给定两个正整数；判断它们是否都是偶数。若是，则用2约简；若不是则执行第二步。
       第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。
       则第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数。
       其中所说的“等数”，就是最大公约数。
       求“等数”的办法是“更相减损”法。所以更相减损法也叫等值算法。
最小公倍数
    几个数共有的倍数叫做这几个数的公倍数，其中除0以外最小的一个公倍数，叫做这几个数的最小公倍数。
计算方法
    ① 分解质因数法
       先把这几个数的质因数写出来，最小公倍数等于它们所有的质因数的乘积
       （如果有几个质因数相同，则比较几个数中哪个数有该质因数的个数较多，乘较多的次数）。
    ② 公式法
       两个数的乘积等于这两个数的最大公约数与最小公倍数的积。
       证明 (a,b)[a,b]=ab，(a,b)表示a,b的最大公约数，[a,b]表示a,b的最小公倍数
       方法1.
       a,b的公倍数都是[a,b]的倍数。
       要证明(a,b)[a,b]=ab，
       只要证明(a,b)[a,b]>=ab···①且(a,b)[a,b]<=ab···②
       ①式等价于[a,b]>=ab/(a,b)
       则①式右值为a和b的公倍数，
       则大于等于最小公倍数，得证。
       ②式等价于(a,b)>=ab/[a,b]
       设m=[a,b]/b
       则②式右值为a/m，为a的约数
       同理右值也为b的约数
       所以②式右值小于等最大公约数
       得证。
       方法2.
       设(a,b)=k
       则a=mk,b=nk
       mn互质
       则[a,b]=m×n×k
       所以ab=mnk²，(a,b)[a,b]=mnk²，得证。

切线
    设点A是曲线C上一点，B为另一点，作割线AB，当B沿曲线C移动而趋近于A时，
    如果割线AB绕点A旋转而趋于一极限位置，即直线AT，
    则称直线AT为曲线y=f(x)在点A处的切线。
    曲线C为函数y=f(x)的图形的情形，点A(x0,y0)，B(x,y)，割线AB的斜率为
    tanβ=(y-y0)/(x-x0)=(f(x)-f(x0))/(x-x0),其中β是割线AB的倾角
    当点B沿曲线C运动趋于点A，x趋于x0,
    若当x→x0时，极限存在，设为k，
    k=lim (f(x)-f(x0))/(x-x0)
      x→x0
    即k是割线AB斜率的极限，也就是切线AT的斜率，这里k=tanα，α为切线AT的倾角。
    因此过点A且以k为斜率的直线AT就是曲线C在点A处的切线。

导数
    k=lim (f(x)-f(x0))/(x-x0)=lim Δy/Δx=lim (f(x0+Δx)-f(x0))/Δx
      x→x0                    Δx→0      Δx→0
    我们把此极限成为导数。

函数在一点处的导数
    定义：设函数y=f(x)在点x0的某个邻域内有定义，当自变量x在x0处取得增量Δx（x0+Δx仍然在该邻域内）时，
    因变量y相应的取得增量Δy=f(x0+Δx)-f(x0),
    若lim Δy/Δx存在，则称函数y=f(x)在点x0处可导，
      Δx→0
    并称该极限为函数y=f(x)在点x0处导数，记为f'(x0),
    f'(x0)=lim Δy/Δx=lim (f(x0+Δx)-f(x0))/Δx
            Δx→0       Δx→0
   也可记作     |          |
            y'=|x=x0,dy/dx|x=x0
   或         |
   y'=df(x)/dx|x=x0

切线方程
    平面曲线C：y=f(x)，点A(x0,y0)是曲线y=f(x)上的一点，且函数y=f(x)在x0处可导，
    y=f(x)在点A处的切线斜率：k=tanα=lim (f(x0)+Δx)/Δx=f'(x0)
                                 Δx→0
    有直线的点斜式方程y-y0=k(x-x0)可以得到切线方程：y-f(x0)=f'(x0)(x-x0),即y=f(x0)+f'(x0)(x-x0)。

求平面曲线C：y=f(x)上点A(x0,y0)的切线与x轴的交点横坐标
    即求切线方程f(x0)+f'(x0)(x-x0)=0的解
    得x=x0-f(x)/'f(x0)

切线是曲线的线性逼近


迭代法
    迭代法是一种逐次逼近法，是一种不断用变量的旧值递推新值的过程。
    基本思想：
    首先给定方程的一个粗糙的初始近似根,
    然后用一个固定公式反复校正这个根的近似值使之逐步精确化,
    直到满足预先给定的精度要求为止。

迭代法求x=√￣a。
    即x²-a=0的解。
    设平面曲线C：y=f(x)=x²-a，取平面曲线C上任意点A(xn,f(xn))
    过点A作曲线C的切线AT，得切线方程为y=f(xn)+f'(xn)(x-x(n))
    则切线AT与x轴的交点横坐标，即切线的根x(n+1)=xn-f(xn)/f'(xn)
    即x(n+1)=xn-((xn)²-a)/2xn=1/2(xn+a/xn)。
    不断的执行上述步骤，可以发现x(n+1)不断的趋于y=0的x的点，
    当xn与x(n+1)差的绝对值大于或等于某个精度时，认为此时的x(n+1)是方程f(x)=0的解
    上式x(n+1)=1/2(xn+a/xn)为求平方根的迭代公式,记为g(x)。
    然后按以下步骤执行：
    ⑴ 选一个方程的近似根，赋给变量x0；
    ⑵ 将x0的值保存于变量x1，然后计算g(x1)，并将结果存于变量x0；
    ⑶ 当x0与x1的差的绝对值还小于指定的精度要求时，重复步骤⑵的计算。
    若方程有根，并且用上述方法计算出来的近似根序列收敛，则按上述方法求得的x0就认为是方程的根。